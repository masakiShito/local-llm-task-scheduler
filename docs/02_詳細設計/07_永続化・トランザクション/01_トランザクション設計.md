# 詳細設計：トランザクション設計（MVP）

## 1. 本書の目的

本書は、本システムにおける各 API・処理単位ごとのトランザクション境界を明確にし、
データ不整合の防止および実装時の判断基準を提供することを目的とする。

---

## 2. トランザクション設計の基本方針

- 書き込みを伴う処理は必ずトランザクション管理下で行う
- 読み取り専用処理ではトランザクションを明示的に張らない
- トランザクションは **できるだけ短く** 保つ
- 外部サービス（LLM 等）呼び出しはトランザクション外で行う

---

## 3. API 別トランザクション設計

### 3.1 Task 系 API

#### 対象 API

- POST /tasks
- PATCH /tasks/{task_id}
- DELETE /tasks/{task_id}

#### トランザクション境界

- API リクエスト受信〜DB 更新完了までを 1 トランザクションとする

#### ロールバック条件

- バリデーションエラー
- DB 制約違反
- 例外発生時

---

### 3.2 Event 系 API

#### 対象 API

- POST /events
- PATCH /events/{event_id}
- DELETE /events/{event_id}

#### トランザクション境界

- Event 単体の CRUD を 1 トランザクションとする

#### 補足

- locked は常に true のため更新対象外
- 日付を跨ぐ Event も単一レコードとして扱う

---

### 3.3 Plan 参照系 API

#### 対象 API

- GET /plans
- GET /plans/{plan_id}
- GET /plans/{plan_id}/blocks

#### トランザクション

- 明示的なトランザクションは不要
- READ COMMITTED による一貫性を前提とする

---

## 4. POST /plans/generate のトランザクション詳細

### 4.1 処理単位

以下を **1 トランザクション** として扱う。

1. Plan レコード作成
2. PlanBlock レコード一括作成

### 4.2 トランザクション外処理

- LLM による summary 生成
- summary 更新は別トランザクション

---

### 4.3 正常系フロー（概念）

1. トランザクション開始
2. Plan INSERT
3. PlanBlock INSERT（複数）
4. トランザクション COMMIT
5. LLM 呼び出し
6. Plan.summary UPDATE（別トランザクション）

---

### 4.4 異常系フロー

#### DB エラー発生時

- Plan / PlanBlock はすべてロールバック
- クライアントへ 500 エラー返却

#### LLM 失敗時

- Plan / PlanBlock は保存済み
- summary は null
- warnings に W-0203 を追加

---

## 5. ネストトランザクションの扱い

- 明示的なネストトランザクションは使用しない
- サービス層でトランザクション境界を統一管理する
- ORM の自動 commit に依存しない

---

## 6. 排他制御

### 6.1 MVP 前提

- 単一ユーザー
- 同時実行数は極小

### 6.2 対応方針

- 排他ロックは使用しない
- 一意制約は設けない
- デッドロック対策は不要とする

---

## 7. 例外処理方針

- 例外は必ずトランザクション境界で捕捉する
- 例外発生時は即ロールバック
- 例外内容はログに記録する（レスポンスには含めない）

---

## 8. 実装上の注意事項

- トランザクション開始位置は Controller ではなく Service 層とする
- ORM（SQLAlchemy 等）の session.commit() / rollback() を明示的に制御する
- finally で session.close() を必ず実行する

---

## 9. テスト観点

- PlanBlock 作成失敗時に Plan が残らないこと
- LLM 失敗時に Plan が正常に取得できること
- 例外発生時に二重 commit が起きないこと
- 同一 API の連続呼び出しで不整合が発生しないこと
