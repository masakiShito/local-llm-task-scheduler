# 詳細設計：永続化設計（テーブル操作単位・INSERT 順序）（MVP）

## 1. 本書の目的

本書は、各ユースケース／API における DB 操作（INSERT/UPDATE/DELETE/SELECT）の単位と順序を定義し、
外部キー整合性・データ再現性・実装一貫性を担保することを目的とする。

---

## 2. 永続化対象テーブル（MVP）

| テーブル    | 主キー   | 説明         |
| ----------- | -------- | ------------ |
| tasks       | task_id  | タスク       |
| events      | event_id | 固定予定     |
| plans       | plan_id  | 計画         |
| plan_blocks | block_id | 計画ブロック |

---

## 3. 共通ルール（DB 操作）

### 3.1 ID 採番

- 主キーは UUID（アプリ側で採番）とする
- INSERT 前に ID を確定し、レスポンスに返せること

### 3.2 日時の扱い

- DB には timezone 情報を保持できる型で保存する（timestamp with time zone を想定）
- API 入出力は ISO8601（TZ 付き）
- date（対象日）は plans.date に date 型で保存する

### 3.3 参照整合性

- plan_blocks.plan_id は plans.plan_id を参照する（FK 必須）
- plan_blocks.task_id は tasks.task_id を参照する（FK 任意、break/buffer は null）

### 3.4 削除方針（MVP）

- tasks：物理削除
- events：物理削除
- plans：物理削除（plan_blocks は CASCADE で削除）

---

## 4. API 別：永続化設計

## 4.1 Task

### 4.1.1 POST /tasks（作成）

- INSERT：tasks（1 件）

INSERT 順序

1. tasks

補足

- status は open を既定値として保存する
- splittable 未指定の場合は true として保存する

### 4.1.2 PATCH /tasks/{task_id}（更新）

- SELECT：tasks（対象 1 件）
- UPDATE：tasks（1 件）

更新順序

1. tasks（存在確認）
2. tasks（UPDATE）

### 4.1.3 DELETE /tasks/{task_id}（削除）

- SELECT：tasks（対象 1 件）
- DELETE：tasks（1 件）

削除順序

1. tasks（存在確認）
2. tasks（DELETE）

---

## 4.2 Event

### 4.2.1 POST /events（作成）

- INSERT：events（1 件）

INSERT 順序

1. events

補足

- locked は常に true として保存する

### 4.2.2 PATCH /events/{event_id}（更新）

- SELECT：events（対象 1 件）
- UPDATE：events（1 件）

更新順序

1. events（存在確認）
2. events（UPDATE）

### 4.2.3 DELETE /events/{event_id}（削除）

- SELECT：events（対象 1 件）
- DELETE：events（1 件）

削除順序

1. events（存在確認）
2. events（DELETE）

---

## 4.3 Plan（参照系）

### 4.3.1 GET /plans（一覧）

- SELECT：plans（0 件以上）

取得順序

1. plans（date_from/date_to フィルタ）

### 4.3.2 GET /plans/{plan_id}（取得）

- SELECT：plans（対象 1 件）

取得順序

1. plans（plan_id）

### 4.3.3 GET /plans/{plan_id}/blocks（ブロック取得）

- SELECT：plan_blocks（0 件以上）
- JOIN：tasks（task_title 同梱のため、任意）

取得順序

1. plan_blocks（plan_id）
2. tasks（必要時のみ）

補足

- task_title は表示用であり、task 削除済みの場合は null とする

---

## 4.4 POST /plans/generate（計画生成）

### 4.4.1 読み取り（生成前）

- SELECT：tasks（status=open）
- SELECT：events（対象日）

読み取り順序

1. tasks（status=open）
2. events（対象日と重なるもの）

補足

- events は対象日と重なるレコードを抽出する
- tasks は status=open のみ取得する

### 4.4.2 書き込み（生成結果保存）

- INSERT：plans（1 件）
- INSERT：plan_blocks（0 件以上、複数）

INSERT 順序（必須）

1. plans（plan_id を確定）
2. plan_blocks（plan_id を参照して一括 INSERT）

コミット条件

- plans が作成されている
- plan_blocks が作成されている（0 件でも可）

ロールバック条件

- plans INSERT 失敗
- plan_blocks INSERT 失敗
- FK/NOT NULL 制約違反
- 例外発生

### 4.4.3 summary 保存（LLM）

- UPDATE：plans（summary のみ）

更新順序（別トランザクション）

1. plans（plan_id 指定で summary UPDATE）

補足

- LLM 失敗時は summary を更新しない（summary=null のまま）
- 警告はレスポンス warnings に含める（W-0203）

---

## 5. 一括 INSERT 方針（plan_blocks）

### 5.1 方針

- plan_blocks は生成結果の配列を **まとめて INSERT** する
- 1 件ずつ INSERT しない（性能・整合性・実装簡潔性）

### 5.2 block_id

- block_id は UUID を事前採番してから INSERT する
- INSERT 後に返却用に再取得しない（MVP では不要）

---

## 6. 参照整合性・削除時の注意

### 6.1 tasks 削除と plan_blocks

- plan_blocks.task_id が tasks を参照しているため、以下いずれかで運用する
  - 運用 A：tasks 削除を禁止し、status=archived のみにする（推奨）
  - 運用 B：tasks 削除を許可し、plan_blocks.task_id の FK を外す（非推奨）
  - 運用 C：tasks 削除を許可し、plan_blocks.task_id を SET NULL にする（推奨）

MVP 採用：運用 C（task 削除時に plan_blocks.task_id を null にする）

理由

- 過去 Plan の参照を壊さない
- tasks 物理削除が可能

### 6.2 plans 削除と plan_blocks

- plans 削除時は plan_blocks を CASCADE 削除する

---

## 7. インデックス（最低限）

| テーブル    | カラム           | 目的         |
| ----------- | ---------------- | ------------ |
| tasks       | status           | open 抽出    |
| tasks       | due_at           | 期限順ソート |
| events      | start_at, end_at | 対象日抽出   |
| plans       | date             | 一覧表示     |
| plan_blocks | plan_id          | plan 内取得  |

---

## 8. テスト観点（永続化）

- plan_blocks の一括 INSERT が成功し、件数が一致すること
- tasks 削除時に plan_blocks.task_id が null となること
- plans 削除時に plan_blocks が削除されること
- LLM 失敗時に summary が null のまま保持されること
